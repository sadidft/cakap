import{db as y}from"./h3MKsja5.js";const f=new TextEncoder,v=new TextDecoder;let p=null;async function w(){if(p!==null)return p;try{const t=await new Function('return import("argon2-browser")')();return p=t.default||t,p}catch{try{const e=await new Function('return import("argon2-wasm")')();return p=e.default||e,p}catch{return p=!1,!1}}}async function E(t){const e=await crypto.subtle.digest("SHA-256",f.encode(t));return Array.from(new Uint8Array(e)).map(a=>a.toString(16).padStart(2,"0")).join("")}async function g(t,e=null,{kdf:a="auto"}={}){if(a==="argon2"&&!await w())throw new Error("Argon2 requested but not available");if(a==="auto"&&(await w()?a="argon2":a="pbkdf2"),a==="argon2"){const o=p,i=e||crypto.getRandomValues(new Uint8Array(16));try{const l=typeof t=="string"?t:new TextDecoder().decode(t),s=await o.hash({pass:l,salt:i,time:2,mem:65536,hashLen:32,raw:!0}),u=s&&s.hash?s.hash:s;return{key:await crypto.subtle.importKey("raw",u,{name:"AES-GCM"},!1,["encrypt","decrypt"]),salt:i,kdf:"argon2"}}catch(l){console.warn("argon2 available but failed to derive, falling back to PBKDF2",l)}}const n=await crypto.subtle.importKey("raw",f.encode(t),{name:"PBKDF2"},!1,["deriveKey"]),r=e||crypto.getRandomValues(new Uint8Array(16));return{key:await crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:1e5,hash:"SHA-256"},n,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),salt:r,kdf:"pbkdf2"}}async function h(t,e){const a=f.encode(JSON.stringify(t)),{key:n,salt:r}=await g(e),c=crypto.getRandomValues(new Uint8Array(12)),o=await crypto.subtle.encrypt({name:"AES-GCM",iv:c},n,a),i=l=>{let s="";for(let u=0;u<l.length;u++)s+=String.fromCharCode(l[u]);return btoa(s)};return{version:1,salt:i(r),iv:i(c),data:i(new Uint8Array(o))}}async function b(t,e){const a=l=>{const s=atob(l),u=new Uint8Array(s.length);for(let d=0;d<s.length;d++)u[d]=s.charCodeAt(d);return u},n=a(t.salt),r=a(t.iv),c=a(t.data),{key:o}=await g(e,n),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:r},o,c);return JSON.parse(v.decode(i))}async function m({encrypt:t=!1,password:e=null}={}){const a=["profiles","kk","kk_versions","ktp","ktp_versions","categories","trash","settings","activity_log"],n={meta:{exported_at:new Date().toISOString(),app:"RT-Cakap",version:"0.1.0"},data:{}};for(const r of a)n.data[r]=await y.table(r).toArray();if(t){if(!e)throw new Error("password required for encrypted export");return{encrypted:!0,payload:await h(n,e)}}return{encrypted:!1,payload:n}}async function k(t,{encrypted:e=!1,password:a=null,merge:n=!1}={}){let r=t;if(e){if(!a)throw new Error("password required for encrypted import");r=await b(t,a)}if(!r||!r.data)throw new Error("invalid payload");for(const[c,o]of Object.entries(r.data))if(n||await y.table(c).clear(),Array.isArray(o)&&o.length>0)for(const i of o)try{await y.table(c).put(i)}catch(l){console.warn("import row error",c,l)}return!0}async function A(t){if(!t)throw new Error("password required");const e=await m({encrypt:!1}),a=await h(e.payload,t);await y.settings.put({key:"encrypted_snapshot",value:a}),await y.settings.put({key:"mode_aman_locked",value:!0});const n=["profiles","kk","kk_versions","ktp","ktp_versions","categories","trash","activity_log"];for(const r of n)try{await y.table(r).clear()}catch{}return!0}async function _(t){if(!t)throw new Error("password required");const e=await y.settings.get("encrypted_snapshot");if(!e||!e.value)throw new Error("no encrypted snapshot found");const a=e.value,n=await b(a,t);return await k(n,{encrypted:!1,merge:!1}),await y.settings.delete("encrypted_snapshot"),await y.settings.put({key:"mode_aman_locked",value:!1}),!0}const K=Object.freeze(Object.defineProperty({__proto__:null,exportAllData:m,importAllData:k,lockDatabase:A,unlockDatabase:_},Symbol.toStringTag,{value:"Module"}));export{K as b,g as d,m as e,E as h,k as i,A as l};
